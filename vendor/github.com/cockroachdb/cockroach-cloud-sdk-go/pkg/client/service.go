// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
// CockroachDB Cloud API
// API version: 2022-03-31

package client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

type Service interface {
	AddAllowlistEntry(ctx _context.Context, clusterId string, allowlistEntry *AllowlistEntry) (*AllowlistEntry, *_nethttp.Response, error)
	AddAllowlistEntry2(ctx _context.Context, clusterId string, entryCidrIp string, entryCidrMask int32, allowlistEntry *AllowlistEntry) (*AllowlistEntry, *_nethttp.Response, error)
	CreateCluster(ctx _context.Context, createClusterRequest *CreateClusterRequest) (*Cluster, *_nethttp.Response, error)
	CreateSQLUser(ctx _context.Context, clusterId string, createSQLUserRequest *CreateSQLUserRequest) (*SQLUser, *_nethttp.Response, error)
	DeleteAllowlistEntry(ctx _context.Context, clusterId string, cidrIp string, cidrMask int32) (*AllowlistEntry, *_nethttp.Response, error)
	DeleteCluster(ctx _context.Context, clusterId string) (*Cluster, *_nethttp.Response, error)
	DeleteSQLUser(ctx _context.Context, clusterId string, name string) (*SQLUser, *_nethttp.Response, error)
	EnableCMEK(ctx _context.Context, clusterId string, cMEKClusterSpecification *CMEKClusterSpecification) (*CMEKClusterInfo, *_nethttp.Response, error)
	GetCMEKClusterInfo(ctx _context.Context, clusterId string) (*CMEKClusterInfo, *_nethttp.Response, error)
	GetCluster(ctx _context.Context, clusterId string) (*Cluster, *_nethttp.Response, error)
	ListAllowlistEntries(ctx _context.Context, clusterId string, options *ListAllowlistEntriesOptions) (*ListAllowlistEntriesResponse, *_nethttp.Response, error)
	ListAvailableRegions(ctx _context.Context, options *ListAvailableRegionsOptions) (*ListAvailableRegionsResponse, *_nethttp.Response, error)
	ListClusterNodes(ctx _context.Context, clusterId string, options *ListClusterNodesOptions) (*ListClusterNodesResponse, *_nethttp.Response, error)
	ListClusters(ctx _context.Context, options *ListClustersOptions) (*ListClustersResponse, *_nethttp.Response, error)
	ListSQLUsers(ctx _context.Context, clusterId string, options *ListSQLUsersOptions) (*ListSQLUsersResponse, *_nethttp.Response, error)
	UpdateAllowlistEntry(ctx _context.Context, clusterId string, entryCidrIp string, entryCidrMask int32, allowlistEntry *AllowlistEntry, options *UpdateAllowlistEntryOptions) (*AllowlistEntry, *_nethttp.Response, error)
	UpdateCMEKStatus(ctx _context.Context, clusterId string, updateCMEKStatusRequest *UpdateCMEKStatusRequest) (*CMEKClusterInfo, *_nethttp.Response, error)
	UpdateCluster(ctx _context.Context, clusterId string, updateClusterSpecification *UpdateClusterSpecification, options *UpdateClusterOptions) (*Cluster, *_nethttp.Response, error)
	UpdateSQLUserPassword(ctx _context.Context, clusterId string, name string, updateSQLUserPasswordRequest *UpdateSQLUserPasswordRequest) (*SQLUser, *_nethttp.Response, error)
}

// Service for the Cockroach DB Cloud API v2021-12-28.
type ServiceImpl struct {
	client *Client
}

// NewService creates a new API service.
func NewService(c *Client) Service {
	return &ServiceImpl{client: c}
}

// AddAllowlistEntry executes the request.
func (a *ServiceImpl) AddAllowlistEntry(
	ctx _context.Context, clusterId string, allowlistEntry *AllowlistEntry,
) (*AllowlistEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/networking/allowlist"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if allowlistEntry == nil {
		return nil, nil, reportError("allowlistEntry is required and must be specified")
	}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = allowlistEntry
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue AllowlistEntry
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// AddAllowlistEntry2 executes the request.
func (a *ServiceImpl) AddAllowlistEntry2(
	ctx _context.Context, clusterId string, entryCidrIp string, entryCidrMask int32, allowlistEntry *AllowlistEntry,
) (*AllowlistEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/networking/allowlist/{entry.cidr_ip}/{entry.cidr_mask}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry.cidr_ip"+"}", _neturl.PathEscape(parameterToString(entryCidrIp, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry.cidr_mask"+"}", _neturl.PathEscape(parameterToString(entryCidrMask, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if allowlistEntry == nil {
		return nil, nil, reportError("allowlistEntry is required and must be specified")
	}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = allowlistEntry
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue AllowlistEntry
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// CreateCluster executes the request.
func (a *ServiceImpl) CreateCluster(
	ctx _context.Context, createClusterRequest *CreateClusterRequest,
) (*Cluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if createClusterRequest == nil {
		return nil, nil, reportError("createClusterRequest is required and must be specified")
	}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = createClusterRequest
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue Cluster
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// CreateSQLUser executes the request.
func (a *ServiceImpl) CreateSQLUser(
	ctx _context.Context, clusterId string, createSQLUserRequest *CreateSQLUserRequest,
) (*SQLUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/sql-users"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if createSQLUserRequest == nil {
		return nil, nil, reportError("createSQLUserRequest is required and must be specified")
	}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = createSQLUserRequest
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue SQLUser
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// DeleteAllowlistEntry executes the request.
func (a *ServiceImpl) DeleteAllowlistEntry(
	ctx _context.Context, clusterId string, cidrIp string, cidrMask int32,
) (*AllowlistEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/networking/allowlist/{cidr_ip}/{cidr_mask}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cidr_ip"+"}", _neturl.PathEscape(parameterToString(cidrIp, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cidr_mask"+"}", _neturl.PathEscape(parameterToString(cidrMask, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue AllowlistEntry
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// DeleteCluster executes the request.
func (a *ServiceImpl) DeleteCluster(
	ctx _context.Context, clusterId string,
) (*Cluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue Cluster
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// DeleteSQLUser executes the request.
func (a *ServiceImpl) DeleteSQLUser(
	ctx _context.Context, clusterId string, name string,
) (*SQLUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/sql-users/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue SQLUser
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// EnableCMEK executes the request.
func (a *ServiceImpl) EnableCMEK(
	ctx _context.Context, clusterId string, cMEKClusterSpecification *CMEKClusterSpecification,
) (*CMEKClusterInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/cmek"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if cMEKClusterSpecification == nil {
		return nil, nil, reportError("cMEKClusterSpecification is required and must be specified")
	}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = cMEKClusterSpecification
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue CMEKClusterInfo
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// GetCMEKClusterInfo executes the request.
func (a *ServiceImpl) GetCMEKClusterInfo(
	ctx _context.Context, clusterId string,
) (*CMEKClusterInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/cmek"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue CMEKClusterInfo
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// GetCluster executes the request.
func (a *ServiceImpl) GetCluster(
	ctx _context.Context, clusterId string,
) (*Cluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue Cluster
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// ListAllowlistEntriesOptions contains optional parameters for ListAllowlistEntries.
type ListAllowlistEntriesOptions struct {
	PaginationStartKey *string

	PaginationDirection *string

	PaginationLimit *int32

	PaginationTime *time.Time

	//  - DESC: Sort in descending order. The default order is ascending.
	PaginationOrder *string
}

// ListAllowlistEntries executes the request.
func (a *ServiceImpl) ListAllowlistEntries(
	ctx _context.Context, clusterId string, options *ListAllowlistEntriesOptions,
) (*ListAllowlistEntriesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/networking/allowlist"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if options.PaginationStartKey != nil {
		localVarQueryParams.Add("pagination.start_key", parameterToString(*options.PaginationStartKey, ""))
	}
	if options.PaginationDirection != nil {
		localVarQueryParams.Add("pagination.direction", parameterToString(*options.PaginationDirection, ""))
	}
	if options.PaginationLimit != nil {
		localVarQueryParams.Add("pagination.limit", parameterToString(*options.PaginationLimit, ""))
	}
	if options.PaginationTime != nil {
		localVarQueryParams.Add("pagination.time", parameterToString(*options.PaginationTime, ""))
	}
	if options.PaginationOrder != nil {
		localVarQueryParams.Add("pagination.order", parameterToString(*options.PaginationOrder, ""))
	}
	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue ListAllowlistEntriesResponse
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// ListAvailableRegionsOptions contains optional parameters for ListAvailableRegions.
type ListAvailableRegionsOptions struct {
	// Optional CloudProvider for filtering.   - GCP: The Google Cloud Platform cloud provider.  - AWS: The Amazon Web Services cloud provider.
	Provider *string

	// Optional filter to only show regions available for serverless clusters.
	Serverless *bool

	PaginationStartKey *string

	PaginationDirection *string

	PaginationLimit *int32

	PaginationTime *time.Time

	//  - DESC: Sort in descending order. The default order is ascending.
	PaginationOrder *string
}

// ListAvailableRegions executes the request.
func (a *ServiceImpl) ListAvailableRegions(
	ctx _context.Context, options *ListAvailableRegionsOptions,
) (*ListAvailableRegionsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/available-regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if options.Provider != nil {
		localVarQueryParams.Add("provider", parameterToString(*options.Provider, ""))
	}
	if options.Serverless != nil {
		localVarQueryParams.Add("serverless", parameterToString(*options.Serverless, ""))
	}
	if options.PaginationStartKey != nil {
		localVarQueryParams.Add("pagination.start_key", parameterToString(*options.PaginationStartKey, ""))
	}
	if options.PaginationDirection != nil {
		localVarQueryParams.Add("pagination.direction", parameterToString(*options.PaginationDirection, ""))
	}
	if options.PaginationLimit != nil {
		localVarQueryParams.Add("pagination.limit", parameterToString(*options.PaginationLimit, ""))
	}
	if options.PaginationTime != nil {
		localVarQueryParams.Add("pagination.time", parameterToString(*options.PaginationTime, ""))
	}
	if options.PaginationOrder != nil {
		localVarQueryParams.Add("pagination.order", parameterToString(*options.PaginationOrder, ""))
	}
	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue ListAvailableRegionsResponse
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// ListClusterNodesOptions contains optional parameters for ListClusterNodes.
type ListClusterNodesOptions struct {
	// Optional filter to limit response to a single region.
	RegionName *string

	PaginationStartKey *string

	PaginationDirection *string

	PaginationLimit *int32

	PaginationTime *time.Time

	//  - DESC: Sort in descending order. The default order is ascending.
	PaginationOrder *string
}

// ListClusterNodes executes the request.
func (a *ServiceImpl) ListClusterNodes(
	ctx _context.Context, clusterId string, options *ListClusterNodesOptions,
) (*ListClusterNodesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if options.RegionName != nil {
		localVarQueryParams.Add("region_name", parameterToString(*options.RegionName, ""))
	}
	if options.PaginationStartKey != nil {
		localVarQueryParams.Add("pagination.start_key", parameterToString(*options.PaginationStartKey, ""))
	}
	if options.PaginationDirection != nil {
		localVarQueryParams.Add("pagination.direction", parameterToString(*options.PaginationDirection, ""))
	}
	if options.PaginationLimit != nil {
		localVarQueryParams.Add("pagination.limit", parameterToString(*options.PaginationLimit, ""))
	}
	if options.PaginationTime != nil {
		localVarQueryParams.Add("pagination.time", parameterToString(*options.PaginationTime, ""))
	}
	if options.PaginationOrder != nil {
		localVarQueryParams.Add("pagination.order", parameterToString(*options.PaginationOrder, ""))
	}
	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue ListClusterNodesResponse
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// ListClustersOptions contains optional parameters for ListClusters.
type ListClustersOptions struct {
	// If `true`, show clusters that have been deleted or failed to initialize.
	ShowInactive *bool

	PaginationStartKey *string

	PaginationDirection *string

	PaginationLimit *int32

	PaginationTime *time.Time

	//  - DESC: Sort in descending order. The default order is ascending.
	PaginationOrder *string
}

// ListClusters executes the request.
func (a *ServiceImpl) ListClusters(
	ctx _context.Context, options *ListClustersOptions,
) (*ListClustersResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if options.ShowInactive != nil {
		localVarQueryParams.Add("show_inactive", parameterToString(*options.ShowInactive, ""))
	}
	if options.PaginationStartKey != nil {
		localVarQueryParams.Add("pagination.start_key", parameterToString(*options.PaginationStartKey, ""))
	}
	if options.PaginationDirection != nil {
		localVarQueryParams.Add("pagination.direction", parameterToString(*options.PaginationDirection, ""))
	}
	if options.PaginationLimit != nil {
		localVarQueryParams.Add("pagination.limit", parameterToString(*options.PaginationLimit, ""))
	}
	if options.PaginationTime != nil {
		localVarQueryParams.Add("pagination.time", parameterToString(*options.PaginationTime, ""))
	}
	if options.PaginationOrder != nil {
		localVarQueryParams.Add("pagination.order", parameterToString(*options.PaginationOrder, ""))
	}
	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue ListClustersResponse
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// ListSQLUsersOptions contains optional parameters for ListSQLUsers.
type ListSQLUsersOptions struct {
	PaginationStartKey *string

	PaginationDirection *string

	PaginationLimit *int32

	PaginationTime *time.Time

	//  - DESC: Sort in descending order. The default order is ascending.
	PaginationOrder *string
}

// ListSQLUsers executes the request.
func (a *ServiceImpl) ListSQLUsers(
	ctx _context.Context, clusterId string, options *ListSQLUsersOptions,
) (*ListSQLUsersResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/sql-users"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if options.PaginationStartKey != nil {
		localVarQueryParams.Add("pagination.start_key", parameterToString(*options.PaginationStartKey, ""))
	}
	if options.PaginationDirection != nil {
		localVarQueryParams.Add("pagination.direction", parameterToString(*options.PaginationDirection, ""))
	}
	if options.PaginationLimit != nil {
		localVarQueryParams.Add("pagination.limit", parameterToString(*options.PaginationLimit, ""))
	}
	if options.PaginationTime != nil {
		localVarQueryParams.Add("pagination.time", parameterToString(*options.PaginationTime, ""))
	}
	if options.PaginationOrder != nil {
		localVarQueryParams.Add("pagination.order", parameterToString(*options.PaginationOrder, ""))
	}
	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue ListSQLUsersResponse
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateAllowlistEntryOptions contains optional parameters for UpdateAllowlistEntry.
type UpdateAllowlistEntryOptions struct {
	FieldMask *string
}

// UpdateAllowlistEntry executes the request.
func (a *ServiceImpl) UpdateAllowlistEntry(
	ctx _context.Context, clusterId string, entryCidrIp string, entryCidrMask int32, allowlistEntry *AllowlistEntry, options *UpdateAllowlistEntryOptions,
) (*AllowlistEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/networking/allowlist/{entry.cidr_ip}/{entry.cidr_mask}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry.cidr_ip"+"}", _neturl.PathEscape(parameterToString(entryCidrIp, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"entry.cidr_mask"+"}", _neturl.PathEscape(parameterToString(entryCidrMask, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if allowlistEntry == nil {
		return nil, nil, reportError("allowlistEntry is required and must be specified")
	}

	if options.FieldMask != nil {
		localVarQueryParams.Add("field_mask", parameterToString(*options.FieldMask, ""))
	}
	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = allowlistEntry
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue AllowlistEntry
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateCMEKStatus executes the request.
func (a *ServiceImpl) UpdateCMEKStatus(
	ctx _context.Context, clusterId string, updateCMEKStatusRequest *UpdateCMEKStatusRequest,
) (*CMEKClusterInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/cmek"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if updateCMEKStatusRequest == nil {
		return nil, nil, reportError("updateCMEKStatusRequest is required and must be specified")
	}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = updateCMEKStatusRequest
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue CMEKClusterInfo
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateClusterOptions contains optional parameters for UpdateCluster.
type UpdateClusterOptions struct {
	FieldMask *string
}

// UpdateCluster executes the request.
func (a *ServiceImpl) UpdateCluster(
	ctx _context.Context, clusterId string, updateClusterSpecification *UpdateClusterSpecification, options *UpdateClusterOptions,
) (*Cluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if updateClusterSpecification == nil {
		return nil, nil, reportError("updateClusterSpecification is required and must be specified")
	}

	if options.FieldMask != nil {
		localVarQueryParams.Add("field_mask", parameterToString(*options.FieldMask, ""))
	}
	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = updateClusterSpecification
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue Cluster
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateSQLUserPassword executes the request.
func (a *ServiceImpl) UpdateSQLUserPassword(
	ctx _context.Context, clusterId string, name string, updateSQLUserPasswordRequest *UpdateSQLUserPasswordRequest,
) (*SQLUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath := a.client.cfg.ServerURL

	localVarPath := localBasePath + "/api/v1/clusters/{cluster_id}/sql-users/{name}/password"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", _neturl.PathEscape(parameterToString(clusterId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if updateSQLUserPasswordRequest == nil {
		return nil, nil, reportError("updateSQLUserPasswordRequest is required and must be specified")
	}

	// Determine the Content-Type header.
	localVarHTTPContentTypes := []string{"application/json"}

	// Set Content-Type header.
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// Determine the Accept header.
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// Set Accept header.
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Body params.
	localVarPostBody = updateSQLUserPasswordRequest
	req, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return nil, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return nil, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := Error{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return nil, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return nil, localVarHTTPResponse, newErr
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return nil, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return nil, localVarHTTPResponse, newErr
	}

	var localVarReturnValue SQLUser
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := Error{
			body:  localVarBody,
			error: err.Error(),
		}
		return &localVarReturnValue, localVarHTTPResponse, newErr
	}

	return &localVarReturnValue, localVarHTTPResponse, nil
}
